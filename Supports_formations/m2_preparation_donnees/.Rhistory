"A","B",10,121,
"A1","B2",2,13,
"D","G",12,123
)
library(tidyverse)
df<-tribble(
~colA,~colB,~colC,~colD,
"A","B",12,123,
"A","B",10,121,
"A1","B2",2,13,
"D","G",12,123
)
View(df)
df %>%
group_by(colA,colB) %>%
add_count() %>%
filter(n==1)
doublons <- duplicated (df,by=c(colA,colB))
doublons <- duplicated (df,by=c('colA','colB'))
?duplicated
x <- c(9:20, 1:5, 3:7, 0:8)
x
duplicated(iris)[140:143]
duplicated(iris)[14:143]
duplicated(iris)[14:145]
df
df<-tribble(
~colA,~colB,~colC,~colD,
"A","B",12,123,
"A","B",10,121,
"A1","B2",2,13,
"D","G",12,123,
"A","B",10,121
)
df %>%
group_by(colA,colB) %>%
add_count() %>%
filter(n==1)
df<-tribble(
~colA,~colB,~colC,~colD,
"A","B",12,123,
"A","B",10,121,
"A1","B2",2,13,
"D","G",12,123,
"A","B",10,121
)
df
df[!duplicated(df[,colA]),]
df[!duplicated(df[,"colA"]),]
df[!duplicated(df[,c("colA", "colB")]),]
df<-tribble(
~colA,~colB,~colC,~colD,
"A","B",12,123,
"A","B1",10,121,
"A1","B2",2,13,
"D","G",12,123,
"A","B",10,121
)
df %>%
group_by(colA,colB) %>%
add_count() %>%
filter(n==1)
df[!duplicated(df[,"colA"]),]
df[!duplicated(df[,c("colA", "colB")]),]
install.packages("sf")
library(sf)
dom <- "Y:/mapinfo/Eau/Eau_sout/bdlisa/v2_2018/reu_lisa_n2o1.tab"
10.9+16.5
library(bookdown)
getwd()
18
# essai
monBarplot('1148', mesLevels= c( "Ne se prononce pas", "Oui" , "Plutôt oui", "Plutôt non", "Non"))
monBarplot <- function (maQuestion ='1148', mesLevels=levels ((reponses %>% pull (questions %>%
filter (qid == maQuestion) %>%
pull (title))) %>%
as.factor ())) {
# récupération du nom de la variable dans le tableau reponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
mutate_all (.funs = as.factor) %>%
na.omit () %>%
mutate_all (.funs = ~ factor (.x, levels = mesLevels))
## just demonstrating match, you don't need to run this
match (names(data), questions$title)
# renommage de la variable pour avoir son énoncé en clair sur le graphique
names(data) <- questions$question [match (names(data), questions$title)]
# titre du graphique
graphTitle <- names (data)
ggplot (data=data, aes (x = get (graphTitle))) +
geom_bar(fill = "#AC3E31") +
ylab ("Nombre de répondants") +
xlab ("") +
ggtitle (graphTitle) +
coord_flip ()
}
# essai
monBarplot('1148', mesLevels= c( "Ne se prononce pas", "Oui" , "Plutôt oui", "Plutôt non", "Non"))
monLikert <- function (maQuestion ='1088', maSelection = (1:(sousQuestions %>%
filter (parent_qid == maQuestion) %>%
nrow ()))) {
# IdMaQuestion est une chaîne de caractères qui va servir à sélectionner les colonnes du dataframe des réponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# Identification des sous-questions de la question sélectionnée
mesSousQuestions <- sousQuestions %>%
filter (parent_qid == maQuestion)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
#    select (maSelection) %>%
mutate_all (.funs = as.factor) %>%
mutate_all (.funs = ~ factor (.x, levels = c("Non", "Plutôt non", "Ne se prononce pas", "Plutôt oui", "Oui")))
data <- data [rowSums (is.na (data)) != ncol(data), ]
## just demonstrating match, you don't need to run this
match (names (data), mesSousQuestions$title)
# renommage des variables pour avoir les sous-questions en clair sur le graphique
names(data) <- mesSousQuestions$sous_question [match (names(data), mesSousQuestions$title)]
# titre du graphique
graphTitle <- questions  %>%
filter (qid == maQuestion) %>%
select (question) %>%
pull ()
# visualisation du likert
likert (data)
# création du likert
Result <- likert (data)
# graphique
plot (Result, type = "bar") +
ggtitle (graphTitle)
}
monLikert(maQuestion ='1087', maSelection = c(1,2))
####################
# chargement des données avec le package LimeRick
# library (devtools)
# devtools::install_github("kalimu/LimeRick")
library (LimeRick)
library (tidyverse)
library (likert)
monLikert(maQuestion ='1087', maSelection = c(1,2))
monBarplot <- function (maQuestion ='1148', mesLevels=levels ((reponses %>% pull (questions %>%
filter (qid == maQuestion) %>%
pull (title))) %>%
as.factor ())) {
# récupération du nom de la variable dans le tableau reponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
mutate_all (.funs = as.factor) %>%
na.omit () %>%
mutate_all (.funs = ~ factor (.x, levels = mesLevels))
## just demonstrating match, you don't need to run this
match (names(data), questions$title)
# renommage de la variable pour avoir son énoncé en clair sur le graphique
names(data) <- questions$question [match (names(data), questions$title)]
# titre du graphique
graphTitle <- names (data)
ggplot (data=data, aes (x = get (graphTitle))) +
geom_bar(fill = "#AC3E31") +
ylab ("Nombre de répondants") +
xlab ("") +
ggtitle (graphTitle) +
coord_flip ()
}
##################################################
# une fonction pour les likert
###############################################################
### Cette fonction est pour les questions avec sous-questions mais sans classement.
### Les modalités sont ordonnées automatiquement par la fonction likert
### On peut si besoin selectionner les sous-questions à représenter ; par défaut toutes le sont
#likert.options (low.color = "#D8B365",
#               high.color = "#5AB4AC",
#               neutral.color = "grey90", neutral.color.ramp = "white",
#                ordered = TRUE,
#                )
monLikert <- function (maQuestion ='1088', maSelection = (1:(sousQuestions %>%
filter (parent_qid == maQuestion) %>%
nrow ()))) {
# IdMaQuestion est une chaîne de caractères qui va servir à sélectionner les colonnes du dataframe des réponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# Identification des sous-questions de la question sélectionnée
mesSousQuestions <- sousQuestions %>%
filter (parent_qid == maQuestion)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
#    select (maSelection) %>%
mutate_all (.funs = as.factor) %>%
mutate_all (.funs = ~ factor (.x, levels = c("Non", "Plutôt non", "Ne se prononce pas", "Plutôt oui", "Oui")))
data <- data [rowSums (is.na (data)) != ncol(data), ]
## just demonstrating match, you don't need to run this
match (names (data), mesSousQuestions$title)
# renommage des variables pour avoir les sous-questions en clair sur le graphique
names(data) <- mesSousQuestions$sous_question [match (names(data), mesSousQuestions$title)]
# titre du graphique
graphTitle <- questions  %>%
filter (qid == maQuestion) %>%
select (question) %>%
pull ()
# visualisation du likert
likert (data)
# création du likert
Result <- likert (data)
# graphique
plot (Result, type = "bar", low.color = "#0a645a", high.color = "#C36B12",  neutral.color = "grey80",
wrap = 40, legend = "", legend.position = "bottom") +
ggtitle (graphTitle) +
ylab ("") +
theme (panel.background = element_rect (size = 1, color = NA, fill = "grey90"),
axis.text=element_text(size=12),
axis.title=element_text(size=14),
legend.text=element_text(size=11),
plot.title = element_text(size=16))
}
monLikert ('1088')
monLikert <- function (maQuestion ='1088', maSelection = (1:(sousQuestions %>%
filter (parent_qid == maQuestion) %>%
nrow ()))) {
# IdMaQuestion est une chaîne de caractères qui va servir à sélectionner les colonnes du dataframe des réponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# Identification des sous-questions de la question sélectionnée
mesSousQuestions <- sousQuestions %>%
filter (parent_qid == maQuestion)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
#    select (maSelection) %>%
mutate_all (.funs = as.factor) %>%
mutate_all (.funs = ~ factor (.x, levels = c("Non", "Plutôt non", "Ne se prononce pas", "Plutôt oui", "Oui")))
data <- data [rowSums (is.na (data)) != ncol(data), ]
## just demonstrating match, you don't need to run this
match (names (data), mesSousQuestions$title)
# renommage des variables pour avoir les sous-questions en clair sur le graphique
names(data) <- mesSousQuestions$sous_question [match (names(data), mesSousQuestions$title)]
# titre du graphique
graphTitle <- questions  %>%
filter (qid == maQuestion) %>%
select (question) %>%
pull ()
# visualisation du likert
likert (data)
# création du likert
Result <- likert (data)
# graphique
plot (Result, type = "bar") +
ggtitle (graphTitle)
}
monLikert(maQuestion ='1087', maSelection = c(1,2))
rm (list = ls ())
####################
# chargement des données avec le package LimeRick
# library (devtools)
# devtools::install_github("kalimu/LimeRick")
library (LimeRick)
library (tidyverse)
library (likert)
# set link to the LimeSurvey API on the demo remote server
options(lsAPIurl = 'http://snefsu.org/limesurvey/admin/remotecontrol')
# set LimeSurvey user login data for survey testing purposes
options (lsUser = "Pascal")
rm (list = ls ())
####################
# chargement des données avec le package LimeRick
# library (devtools)
# devtools::install_github("kalimu/LimeRick")
library (LimeRick)
library (tidyverse)
library (likert)
# set link to the LimeSurvey API on the demo remote server
options(lsAPIurl = 'http://snefsu.org/limesurvey/admin/remotecontrol')
# set LimeSurvey user login data for survey testing purposes
options (lsUser = "Pascal")
options (lsPass = "5GjpRD7TxbUN")
lsSessionKey ("release")
lsSessionKey ("set")
# on fixe le locale
Sys.setlocale ("LC_ALL", "French")
# L'enquête qui nous intéresse
surveyID <- '761195'
questionList <- lsList ("questions", surveyID)
### liste des questions ; un peu de nettoyage du texte
questions <- questionList %>%
select (qid, parent_qid, question, title) %>%
filter (parent_qid == "0") %>%
mutate (question = str_replace (question, '<p><span style="font-size:18px;">', ''),
question = str_replace (question, '<span style="font-family:Tahoma, Geneva, sans-serif;">', ''),
question = str_replace (question, '</h4>', ''),
question = str_replace (question, '<h4>', ''),
question = str_replace (question, '</span></span></p>', ''),
question = str_replace (question, '</span></p>', ''))
### liste des sous-questions ; un peu de nettoyage du texte
# la variable 'title' sert pour faire une jointure et récupérer les intitulés en clair des sous-questions
sousQuestions <- questionList %>%
select (qid, parent_qid, question, title) %>%
filter (parent_qid != "0") %>%
mutate (question = str_replace (question, '<span style="font-size:16px;">', ''),
question = str_replace (question, '</span>', '')) %>%
rename (sous_question = question) %>%
left_join (questions %>% select (qid, title), by = c('parent_qid' = 'qid')) %>%
mutate (title = paste0 (title.y, '.', title.x, '.')) %>%
select (-title.x, -title.y)
### chargement des réponses
reponses <- lsGetResponses(surveyID, languageCode = "fr")
reponses [reponses == ""] <- NA
reponses <- droplevels (reponses)
monLikert <- function (maQuestion ='1088', maSelection = (1:(sousQuestions %>%
filter (parent_qid == maQuestion) %>%
nrow ()))) {
# IdMaQuestion est une chaîne de caractères qui va servir à sélectionner les colonnes du dataframe des réponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# Identification des sous-questions de la question sélectionnée
mesSousQuestions <- sousQuestions %>%
filter (parent_qid == maQuestion)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
#    select (maSelection) %>%
mutate_all (.funs = as.factor) %>%
mutate_all (.funs = ~ factor (.x, levels = c("Non", "Plutôt non", "Ne se prononce pas", "Plutôt oui", "Oui")))
data <- data [rowSums (is.na (data)) != ncol(data), ]
## just demonstrating match, you don't need to run this
match (names (data), mesSousQuestions$title)
# renommage des variables pour avoir les sous-questions en clair sur le graphique
names(data) <- mesSousQuestions$sous_question [match (names(data), mesSousQuestions$title)]
# titre du graphique
graphTitle <- questions  %>%
filter (qid == maQuestion) %>%
select (question) %>%
pull ()
# visualisation du likert
likert (data)
# création du likert
Result <- likert (data)
# graphique
plot (Result, type = "bar") +
ggtitle (graphTitle)
}
monLikert(maQuestion ='1087', maSelection = c(1,2))
monLikert(maQuestion ='1088', maSelection = c(1,2))
monLikert(maQuestion ='1087', maSelection = c(1,2))
monLikert(maQuestion ='1087', maSelection = c(1,2)) + ggtitle ("Principales raisons")
rm (list = ls ())
####################
# chargement des données avec le package LimeRick
# library (devtools)
# devtools::install_github("kalimu/LimeRick")
library (LimeRick)
library (tidyverse)
library (likert)
# set link to the LimeSurvey API on the demo remote server
options(lsAPIurl = 'http://snefsu.org/limesurvey/admin/remotecontrol')
# set LimeSurvey user login data for survey testing purposes
options (lsUser = "Pascal")
options (lsPass = "5GjpRD7TxbUN")
lsSessionKey ("release")
lsSessionKey ("set")
# on fixe le locale
Sys.setlocale ("LC_ALL", "French")
# L'enquête qui nous intéresse
surveyID <- '761195'
questionList <- lsList ("questions", surveyID)
### liste des questions ; un peu de nettoyage du texte
questions <- questionList %>%
select (qid, parent_qid, question, title) %>%
filter (parent_qid == "0") %>%
mutate (question = str_replace (question, '<p><span style="font-size:18px;">', ''),
question = str_replace (question, '<span style="font-family:Tahoma, Geneva, sans-serif;">', ''),
question = str_replace (question, '</h4>', ''),
question = str_replace (question, '<h4>', ''),
question = str_replace (question, '</span></span></p>', ''),
question = str_replace (question, '</span></p>', ''))
### liste des sous-questions ; un peu de nettoyage du texte
# la variable 'title' sert pour faire une jointure et récupérer les intitulés en clair des sous-questions
sousQuestions <- questionList %>%
select (qid, parent_qid, question, title) %>%
filter (parent_qid != "0") %>%
mutate (question = str_replace (question, '<span style="font-size:16px;">', ''),
question = str_replace (question, '</span>', '')) %>%
rename (sous_question = question) %>%
left_join (questions %>% select (qid, title), by = c('parent_qid' = 'qid')) %>%
mutate (title = paste0 (title.y, '.', title.x, '.')) %>%
select (-title.x, -title.y)
### chargement des réponses
reponses <- lsGetResponses(surveyID, languageCode = "fr")
reponses [reponses == ""] <- NA
reponses <- droplevels (reponses)
monLikert <- function (maQuestion ='1088', maSelection = (1:(sousQuestions %>%
filter (parent_qid == maQuestion) %>%
nrow ()))) {
# IdMaQuestion est une chaîne de caractères qui va servir à sélectionner les colonnes du dataframe des réponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# Identification des sous-questions de la question sélectionnée
mesSousQuestions <- sousQuestions %>%
filter (parent_qid == maQuestion)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
#    select (maSelection) %>%
mutate_all (.funs = as.factor) %>%
mutate_all (.funs = ~ factor (.x, levels = c("Non", "Plutôt non", "Ne se prononce pas", "Plutôt oui", "Oui")))
data <- data [rowSums (is.na (data)) != ncol(data), ]
## just demonstrating match, you don't need to run this
match (names (data), mesSousQuestions$title)
# renommage des variables pour avoir les sous-questions en clair sur le graphique
names(data) <- mesSousQuestions$sous_question [match (names(data), mesSousQuestions$title)]
# titre du graphique
graphTitle <- questions  %>%
filter (qid == maQuestion) %>%
select (question) %>%
pull ()
# visualisation du likert
likert (data)
# création du likert
Result <- likert (data)
# graphique
plot (Result, type = "bar") +
ggtitle (graphTitle)
}
monLikert(maQuestion ='1087', maSelection = c(1,2))
monBarplot <- function (maQuestion ='1148', mesLevels=levels ((reponses %>% pull (questions %>%
filter (qid == maQuestion) %>%
pull (title))) %>%
as.factor ())) {
# récupération du nom de la variable dans le tableau reponses
IdMaQuestion <- questions %>%
filter (qid == maQuestion) %>%
pull (title)
# extraction du jeu de données qui va être graphé
data <- reponses %>%
select (starts_with (IdMaQuestion)) %>%
mutate_all (.funs = as.factor) %>%
na.omit () %>%
mutate_all (.funs = ~ factor (.x, levels = mesLevels))
## just demonstrating match, you don't need to run this
match (names(data), questions$title)
# renommage de la variable pour avoir son énoncé en clair sur le graphique
names(data) <- questions$question [match (names(data), questions$title)]
# titre du graphique
graphTitle <- names (data)
ggplot (data=data, aes (x = get (graphTitle))) +
geom_bar(fill = "#AC3E31") +
ylab ("Nombre de répondants") +
xlab ("") +
ggtitle (graphTitle) +
coord_flip ()
}
# essai
monBarplot('1148', mesLevels= c( "Ne se prononce pas", "Oui" , "Plutôt oui", "Plutôt non", "Non"))
lachez_vous <- reponses %>%
filter (!is.na(Q204)) %>%
select (Q204) %>%
datatable(colnames = '') %>%
formatStyle (1, color = 'black', fontFamily='tahoma', fontSize=8)
lachez_vous
lachez_vous <- reponses %>%
filter (!is.na(Q204)) %>%
select (Q204) %>%
datatable(colnames = '') %>%
formatStyle (1, color = 'black', fontFamily='tahoma', fontSize=8)
library(DT)
lachez_vous
lachez_vous <- reponses %>%
filter (!is.na(Q204)) %>%
select (Q204) %>%
datatable(colnames = '') %>%
formatStyle (1, color = 'black', fontFamily='tahoma', fontSize=8)
lachez_vous
save.image(file = "enquete_reorg.RData")
View(lachez_vous)
View(reponses)
View(reponses)
37+59+14
37/110
View(reponses)
reponses %>% filter (!is.na(Q205))
reponses %>% filter (!is.na(Q204))
reponses %>% filter (!is.na(Q204))-> prov
prov
reponses %>% filter (!is.na(Q204)) %>% pull(Q204) %>% datatable()
reponses %>% filter (!is.na(Q204)) %>% pull(Q204)
reponses %>% filter (!is.na(Q204)) %>% select(Q204) %>% datatable(colnames = '')
save.image(file = "T:/Administration/FSU/Intersyndicale_CGDD/2019_01_enquete_reorganisation/enquete_reorg.RData")
128/435
mean(1:6)
webshot::install_phantomjs()
5/.27*100
180*950+120*800+96*430+62*200
(180*950+120*800+96*430+62*200)/(396+62)
108/(96+62)
108/(96+62)
library(bookdown)
bookdown::re,der_book("index.Rmd")
bookdown::render_book("index.Rmd")
setwd("C:/Users/pirz/GitHub/parcours-r/m2_preparation_donnees")
bookdown::render_book("index.Rmd")
getwd()
